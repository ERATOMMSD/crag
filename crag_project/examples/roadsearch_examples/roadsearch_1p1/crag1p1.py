import heapq
import numpy as np
import numpy.random as ra
import platform

from code_pipeline.tests_generation import RoadTestFactory

from crag.crag import CRAG
from crag.pict import PictTestSuiteGenerator
import crag.roadgeometry as rg

import roadevolutionstrategy


class CRAG1P1(CRAG):
    def __init__(self):
        super().__init__(core_params, geometry_params, test_suite_generator,
                         road_evaluate_function, budget_availability_function)
        self.road_evaluate_function = road_evaluate_function
        self.global_evaluation_dict = {}
        def test_and_road_evaluate_function((test, road)):
            return self.global_evaluation_dict[tuple(test)]
        self.evaluate_function = test_and_road_evaluate_function

    def search_roads(self, test_suite):
        roads = []
        for test in test_suite:
            lengths_indices = test[:self.road_section_count]
            kappas_indices = test[self.road_section_count:]

            length_min = [self.min_segment_count * self.ds + i * self.ds * (self.max_segment_count - self.min_segment_count) / self.param_value_count for i in range(self.road_section_count)]
            kappa_min = [-self.global_curvature_bound + i * 2 * self.global_curvature_bound / self.param_value_count for i in range(self.road_section_count)]
            length_max = [self.min_segment_count * self.ds + (i + 1) * self.ds * (self.max_segment_count - self.min_segment_count) / self.param_value_count for i in range(self.road_section_count)]
            kappa_max = [-self.global_curvature_bound + (i + 1) * 2 * self.global_curvature_bound / self.param_value_count for i in range(self.road_section_count)]

            best_road, best_evaluation = roadevolutionstrategy.get_best_road_and_evaluation(self.road_section_count, length_min, length_max, kappa_min, kappa_max, self.ds, self.lane_width, self.map_size, self.evaluate_function)
            self.global_evaluation_dict[tuple(test)] = best_evaluation
            roads.append((test, best_road))
        return roads

def get_arg(args, arg_name, convert_func, default):
    value = default
    if arg_name in args:
        index = args.index(arg_name)
        if index < len(args) - 1:
            value = convert_func(args[index + 1])
    return value

def get_os():
    os = platform.system()
    if os == 'Windows':
        return 'windows'
    elif os == 'Linux':
        return 'linux'
    elif os == 'Darwin':
        return 'mac'
    else:
        return None

def get_fullpath(filename):
    import os
    dirname = os.path.dirname(__file__)
    return os.path.join(dirname, filename)

def get_local_pict_executable():
    host_os = get_os()
    if host_os is None:
        return None

    return get_fullpath(f"./pict-{host_os}")


class CRAGExample:
    """
    Example for using crag as a library
    """

    def __init__(self, executor=None, map_size=None):
        self.executor = executor
        self.map_size = map_size

        import sys
        args = sys.stdin.readline().split(" ")

        core_params = {}
        core_params["use_seed"] = True
        core_params["seed_best"] = True
        core_params["best_ratio"] = get_arg(args, "--best_ratio", float, 0.1)
        core_params["resample"] = True
        core_params["fitness_aggregation_method"] = "average"
        core_params["max_strength"] = get_arg(args, "--max_strength", int, 4)  # We stop increasing n in n-wise combinations when we reach n=MAX_STRENGTH

        geometry_params = {}
        geometry_params["road_section_count"] = get_arg(args, "--road_param_count", int, 8) // 2 # 4 Road Piece Length values + 4 Kappa values
        geometry_params["param_value_count"] = get_arg(args, "--road_param_value_count", int, 4)  # Possible indices for the parameters are 0, 1, 2, 3
        geometry_params["max_road_scalar"] = get_arg(args, "--max_road_scalar", float, 1.5)
        geometry_params["min_road_scalar"] = get_arg(args, "--min_road_scalar", float, 0.2)
        geometry_params["lane_width"] = 10
        geometry_params["map_size"] = 200
        geometry_params["min_radius"] = 15

        self.MIN_OOB_SAMPLE_SIZE = get_arg(args, "--min_oob_sample_size", int, 5)  # We take average of MIN_OOB_SAMPLE_SIZE number of smallest oob distances

        def budget_availability_function():
            return not self.executor.is_over()


        def evaluate_function(road):
            """Evaluate function takes a road generated by CRAG
               and returns a numeric value characterizing the
               (negative) fitness of a road. A road with a smaller
               numeric value is preferable in search. This specific
               function evaluates the road over driving agents
               specified in SBFT'23 Competition."""
            (road_points, is_in_map, is_reframable) = road
            if (not is_in_map) and (not is_reframable):
                return [1000]

            # Check self-intersections and reframe if possible
            if rg.is_likely_self_intersecting(road_points, geometry_params["lane_width"]):
                return [1000]

            if not is_reframable:
                return [1000]

            the_test = RoadTestFactory.create_road_test(road_points)
            test_outcome, description, execution_data = self.executor.execute_test(the_test)
            if execution_data:
                min_oob_distances = heapq.nsmallest(self.MIN_OOB_SAMPLE_SIZE,
                                                    [getattr(x, 'oob_distance') for x in execution_data])
                # Return average of MIN_OOB_SAMPLE_SIZE number of smallest oob distances
                return [sum(min_oob_distances) / len(min_oob_distances)]
            else:
                return [100] # Road determined INVALID


        ptsg = PictTestSuiteGenerator(get_local_pict_executable(), "PICTModel.txt", "PICTSeed.txt")
        self.crag = CRAG(core_params, geometry_params, ptsg, evaluate_function, budget_availability_function)



    def start(self):
        self.crag.generate()
